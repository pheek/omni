// @date: 19. Jan. 2012
// @autor: phi
//
// erstes Testprogramm in "OMNI"

#package ly.gress.omni.test

#import  util.inc
#import  util.date
#external import java.util.ArrayList;

///////////////////////////////////////////////////

// Keine Strichpunkte am Ende einer Anweisung:

al: ArrayList<String>

// Zuweisung mittels Zuweisungspfeil
al ← new ArrayList<String>

// Objektorientierte Aufrufe:
al.add("Hallo")

// Anweisungen mit mehr als einer Zeile aufsplitten:
// "\" unmittelbar vor Zeilenende
al.add\
 ("Welt")


// Schlüsselwörter "for" und "in"
for w in al {
  print "Ausgabe ", w
}

// Wichtige Iterationscollections schon vorgegeben:
for i in sequence(1, 100) {
 ...
}
// ord(100) == sequence(1, 100)
for i in ord(100) {
 ...
}

// 'print' entspricht "System.out.println"
print "Hallo Welt"

// print ohne CR/LF mittels speziellem Befehl (print string):
print_s "Hallo "
print "Welt"


// Automatische Typenerkennung vor dem Compile:
name ← "Philipp" // name wird automatisch "string"
i    ← 4
f    ← 3.9
g    ← 4.0

// String concat mit "," (kein '&', kein '+' ...)
print "Mein Name ist ", name

// Typen können explizit vergeben (deklariert) werden.
// Folgende existieren: real, boolean und diverse int:
// sint8 : signed   int  8 bit
// uint8 : unsigend int  8 bit
// sint16: signed   int 16 bit
// ...
// uint64: unsignen int 64 bit
// abkürzung, da häufig: int = sint32
// real ist 64 bit. sonst real32, real64, real128
x: int
y: real

x ←  8
// Wissenschafltiche Notation
y ← -7.3e2


print "Summe x + y = ", (x + y)

// '..'-Opreator definiert eine Sequenz
for i in 1 .. 99 { // i wird automatisch "int"
  print i, ". Zahl"
  // Mathematische Symbole und Zuweisung aus Unicode
  if(i ≥ 80 AND i ≠ 90 OR i = 40) { 
    print "Achtung groß oder speziell..."
  }
} 


// Bem.: Keine Sondersymbole für AND, OR, XOR und NOT.

ok: boolean

ok ← (false OR true) OR (x > 4)

if(ok) {
  print "Alles in Butter"
}


i ← "Hallo" // falls i nur lokal lokal definiert wurde, somit ist diseses i "frei".
            // hat i schon einen Datentypen, so wird 
            // a) einfach zugewiesen, falls die Typen gleich
            // b) Fehlermeldung, bei inkompatiblen typen.

// Switch am besten ganz verbannen oder durch den PL/I SELECT/WHEN ersetzen
// kein "break"!
// "-" == default
select(i) {
  1      : print "sehr schwach"
  2, 3, 4: print "na ja" 
  5      : print "sehr" 
  5, 6   : print "gut"
  "Hallo": print "das musste ja kommen"
  -: print "nicht definerter Wert"
}
bzw.
select() {
  when x = 1                  : print "sehr schwach"
  when x = 2 OR x = 3 OR x = 4: print "na ja"
  when x = 5                  : print "sehr "
  when x = 6                  : print "gut"
  when x = "Hallo"            : print "das muste ja kommen"
  -                           : "nicht definierter Wert"
}

// return mit einfachem Zuweisungszeichen bei letzter Anweisung.
// Somit ist eine funktionale Denkweise einfacher
func sin(x: real) { // Annaeherung

  // Nochmals: Zeilenumbruch für mehrzeilige Anweisungen 
  ← x - x*x*x/6 + x*x*x*x*x/120 - \ 
    x*x*x*x*x*x*x/(120*7*8)
}


// keyword "proc" für subroutinene ohne Return.
// Damit kann beim Aufruf eine Fehlermeldung generiert werden, wenn
// a) eine proc als Ausdruck aufgerufen wird oder
// b) eine func als Proc aufgerufen wird (PL/1 läßt grüßen)
proc tenTimes() {
  for i in 1 .. 10 {
    print "Hello World"
  }
}

// keyword 'func' für funktionen mit return
// Datentyp "func(x)"
func intregralBis10(f: func(x)) {
  sum ← 0
  for i in 1..10 {
    sum = sum + f(i)
  }
  ← sum
}


// call lambda
t = tenTimesDo(sin())     


///////////////////////////////////
//         Objekte
//


// Test mit Kühen
k      ← new Kuh // k wird automatisch Typ "class Kuh"
k.name ← "vera"
k.jahr ← 1988
k.friss(2.5)
k      ← new Kuh(name ← "Anja", jahr ← 1955)
k.friss(3.5)
k.addGewicht(2.5)

k ← 7 // ERROR: k hat typ "Kuh"

// Analog Unicode: +: Public; -: Private
class Kuh {
  attr {
   +name: string
   +jahr: int
   -gewicht: real
  }

  proc init() {} // empty constructor 
  
  proc check() {
    if (jahr < 1900) {
      throw exception("Jahr zu klein")
    }
  }	
  
  proc addGewicht(kg: real) {
    inc(gewicht, kg) 
  }  
	
  proc friss(kg: real) {
    print name, " frisst ", kg, " kg."
  }  
} // end Kuh


k = new Kalb(name ← "Vera", monat ← 3)
print k // "string()" wird aufgerufen

class Kalb is Kuh {
  attr {
   +monat: int
  }
  
  proc init() {
     jahr ← date.year
  }
  
  func string() { // entspricht in Java ToString
    ← "Kalb ", name, " ist geboren im monat ", monat
  }
}

enum Wochentag {
 MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG, SAMSTAG, SONNTAG
}

for wt in Wochentag.elements() {
  print "noch ein Wochentag: ", wt
}

// analog
for wt in 1 .. Wochentag.size() {
  print "noch ein Wochentag: ", Wochentag.element(wt)
}


feld: real[] {3.8, 4.7e3, -6.9, 5.8} // Index 1..4
for x in feld { // x hat Datentyp "real"
  print (x + 10), " ist einfach groß"
}
feld[4] ← 4.8


